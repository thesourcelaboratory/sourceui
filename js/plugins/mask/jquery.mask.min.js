/**
 * jquery.mask.js
 * @version: v1.14.16
 * @author: Igor Escobar
 *
 * Created by Igor Escobar on 2012-03-10. Please report any bug at github.com/igorescobar/jQuery-Mask-Plugin
 *
 * Copyright (c) 2012 Igor Escobar http://igorescobar.com
 *
 * The MIT License (http://www.opensource.org/licenses/mit-license.php)
 *
 * Permission is hereby granted, free of charge, to any person
 * obtaining a copy of this software and associated documentation
 * files (the "Software"), to deal in the Software without
 * restriction, including without limitation the rights to use,
 * copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the
 * Software is furnished to do so, subject to the following
 * conditions:
 *
 * The above copyright notice and this permission notice shall be
 * included in all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
 * EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
 * OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
 * NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
 * HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
 * WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
 * FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
 * OTHER DEALINGS IN THE SOFTWARE.
 */

/* jshint laxbreak: true */
/* jshint maxcomplexity:17 */
/* global define */

// UMD (Universal Module Definition) patterns for JavaScript modules that work everywhere.
// https://github.com/umdjs/umd/blob/master/templates/jqueryPlugin.js
(function (factory, jQuery, Zepto) {

    if (typeof define === 'function' && define.amd) {
        define(['jquery'], factory);
    } else if (typeof exports === 'object' && typeof Meteor === 'undefined') {
        module.exports = factory(require('jquery'));
    } else {
        factory(jQuery || Zepto);
    }

}(function ($) {
    'use strict';

    var Mask = function (el, mask, options) {

        var p = {
            invalid: [],
            getCaret: function () {
                try {
                    var sel,
                        pos = 0,
                        ctrl = el.get(0),
                        dSel = document.selection,
                        cSelStart = ctrl.selectionStart;

                    // IE Support
                    if (dSel && navigator.appVersion.indexOf('MSIE 10') === -1) {
                        sel = dSel.createRange();
                        sel.moveStart('character', -p.val().length);
                        pos = sel.text.length;
                    }
                    // Firefox support
                    else if (cSelStart || cSelStart === '0') {
                        pos = cSelStart;
                    }

                    return pos;
                } catch (e) {}
            },
            setCaret: function(pos) {
                try {
                    if (el.is(':focus')) {
                        var range, ctrl = el.get(0);

                        // Firefox, WebKit, etc..
                        if (ctrl.setSelectionRange) {
                            ctrl.setSelectionRange(pos, pos);
                        } else { // IE
                            range = ctrl.createTextRange();
                            range.collapse(true);
                            range.moveEnd('character', pos);
                            range.moveStart('character', pos);
                            range.select();
                        }
                    }
                } catch (e) {}
            },
            events: function() {
                el
                .on('keydown.mask', function(e) {
                    el.data('mask-keycode', e.keyCode || e.which);
                    el.data('mask-previus-value', el.val());
                    el.data('mask-previus-caret-pos', p.getCaret());
                    p.maskDigitPosMapOld = p.maskDigitPosMap;
                })
                .on($.jMaskGlobals.useInput ? 'input.mask' : 'keyup.mask', p.behaviour)
                .on('paste.mask drop.mask', function() {
                    setTimeout(function() {
                        el.keydown().keyup();
                    }, 100);
                })
                .on('change.mask', function(){
                    el.data('changed', true);
                })
                .on('blur.mask', function(){
                    if (oldValue !== p.val() && !el.data('changed')) {
                        el.trigger('change');
                    }
                    el.data('changed', false);
                })
                // it's very important that this callback remains in this position
                // otherwhise oldValue it's going to work buggy
                .on('blur.mask', function() {
                    oldValue = p.val();
                })
                // select all text on focus
                .on('focus.mask', function (e) {
                    if (options.selectOnFocus === true) {
                        $(e.target).select();
                    }
                })
                // clear the value if it not complete the mask
                .on('focusout.mask', function() {
                    if (options.clearIfNotMatch && !regexMask.test(p.val())) {
                       p.val('');
                   }
                });
            },
            getRegexMask: function() {
                var maskChunks = [], translation, pattern, optional, recursive, oRecursive, r;

                for (var i = 0; i < mask.length; i++) {
                    translation = jMask.translation[mask.charAt(i)];

                    if (translation) {

                        pattern = translation.pattern.toString().replace(/.{1}$|^.{1}/g, '');
                        optional = translation.optional;
                        recursive = translation.recursive;

                        if (recursive) {
                            maskChunks.push(mask.charAt(i));
                            oRecursive = {digit: mask.charAt(i), pattern: pattern};
                        } else {
                            maskChunks.push(!optional && !recursive ? pattern : (pattern + '?'));
                        }

                    } else {
                        maskChunks.push(mask.charAt(i).replace(/[-\/\\^$*+?.()|[\]{}]/g, '\\$&'));
                    }
                }

                r = maskChunks.join('');

                if (oRecursive) {
                    r = r.replace(new RegExp('(' + oRecursive.digit + '(.*' + oRecursive.digit + ')?)'), '($1)?')
                         .replace(new RegExp(oRecursive.digit, 'g'), oRecursive.pattern);
                }

                return new RegExp(r);
            },
            destroyEvents: function() {
                el.off(['input', 'keydown', 'keyup', 'paste', 'drop', 'blur', 'focusout', ''].join('.mask '));
            },
            val: function(v) {
                var isInput = el.is('input'),
                    method = isInput ? 'val' : 'text',
                    r;

                if (arguments.length > 0) {
                    if (el[method]() !== v) {
                        el[method](v);
                    }
                    r = el;
                } else {
                    r = el[method]();
                }

                return r;
            },
            calculateCaretPosition: function(oldVal) {
                var newVal = p.getMasked(),
                    caretPosNew = p.getCaret();
                if (oldVal !== newVal) {
                    var caretPosOld = el.data('mask-previus-caret-pos') || 0,
                        newValL = newVal.length,
                        oldValL = oldVal.length,
                        maskDigitsBeforeCaret = 0,
                        maskDigitsAfterCaret = 0,
                        maskDigitsBeforeCaretAll = 0,
                        maskDigitsBeforeCaretAllOld = 0,
                        i = 0;

                    for (i = caretPosNew; i < newValL; i++) {
                        if (!p.maskDigitPosMap[i]) {
                            break;
                        }
                        maskDigitsAfterCaret++;
                    }

                    for (i = caretPosNew - 1; i >= 0; i--) {
                        if (!p.maskDigitPosMap[i]) {
                            break;
                        }
                        maskDigitsBeforeCaret++;
                    }

                    for (i = caretPosNew - 1; i >= 0; i--) {
                        if (p.maskDigitPosMap[i]) {
                            maskDigitsBeforeCaretAll++;
                        }
                    }

                    for (i = caretPosOld - 1; i >= 0; i--) {
                        if (p.maskDigitPosMapOld[i]) {
                            maskDigitsBeforeCaretAllOld++;
                        }
                    }

                    // if the cursor is at the end keep it there
                    if (caretPosNew > oldValL) {
                      caretPosNew = newValL * 10;
                    } else if (caretPosOld >= caretPosNew && caretPosOld !== oldValL) {
                        if (!p.maskDigitPosMapOld[caretPosNew])  {
                          var caretPos = caretPosNew;
                          caretPosNew -= maskDigitsBeforeCaretAllOld - maskDigitsBeforeCaretAll;
                          caretPosNew -= maskDigitsBeforeCaret;
                          if (p.maskDigitPosMap[caretPosNew])  {
                            caretPosNew = caretPos;
                          }
                        }
                    }
                    else if (caretPosNew > caretPosOld) {
                        caretPosNew += maskDigitsBeforeCaretAll - maskDigitsBeforeCaretAllOld;
                        caretPosNew += maskDigitsAfterCaret;
                    }
                }
                return caretPosNew;
            },
            behaviour: function(e) {
                e = e || window.event;
                p.invalid = [];

                var keyCode = el.data('mask-keycode');

                if ($.inArray(keyCode, jMask.byPassKeys) === -1) {
                    var newVal = p.getMasked(),
                        caretPos = p.getCaret(),
                        oldVal = el.data('mask-previus-value') || '';

                    // this is a compensation to devices/browsers that don't compensate
                    // caret positioning the right way
                    setTimeout(function() {
                      p.setCaret(p.calculateCaretPosition(oldVal));
                    }, $.jMaskGlobals.keyStrokeCompensation);

                    p.val(newVal);
                    p.setCaret(caretPos);
                    return p.callbacks(e);
                }
            },
            getMasked: function(skipMaskChars, val) {
                var buf = [],
                    value = val === undefined ? p.val() : val + '',
                    m = 0, maskLen = mask.length,
                    v = 0, valLen = value.length,
                    offset = 1, addMethod = 'push',
                    resetPos = -1,
                    maskDigitCount = 0,
                    maskDigitPosArr = [],
                    lastMaskChar,
                    check;

                if (options.reverse) {
                    addMethod = 'unshift';
                    offset = -1;
                    lastMaskChar = 0;
                    m = maskLen - 1;
                    v = valLen - 1;
                    check = function () {
                        return m > -1 && v > -1;
                    };
                } else {
                    lastMaskChar = maskLen - 1;
                    check = function () {
                        return m < maskLen && v < valLen;
                    };
                }

                var lastUntranslatedMaskChar;
                while (check()) {
                    var maskDigit = mask.charAt(m),
                        valDigit = value.charAt(v),
                        translation = jMask.translation[maskDigit];

                    if (translation) {
                        if (valDigit.match(translation.pattern)) {
                            buf[addMethod](valDigit);
                             if (translation.recursive) {
                                if (resetPos === -1) {
                                    resetPos = m;
                                } else if (m === lastMaskChar && m !== resetPos) {
                                    m = resetPos - offset;
                                }

                                if (lastMaskChar === resetPos) {
                                    m -= offset;
                                }
                            }
                            m += offset;
                        } else if (valDigit === lastUntranslatedMaskChar) {
                            // matched the last untranslated (raw) mask character that we encountered
                            // likely an insert offset the mask character from the last entry; fall
                            // through and only increment v
                            maskDigitCount--;
                            lastUntranslatedMaskChar = undefined;
                        } else if (translation.optional) {
                            m += offset;
                            v -= offset;
                        } else if (translation.fallback) {
                            buf[addMethod](translation.fallback);
                            m += offset;
                            v -= offset;
                        } else {
                          p.invalid.push({p: v, v: valDigit, e: translation.pattern});
                        }
                        v += offset;
                    } else {
                        if (!skipMaskChars) {
                            buf[addMethod](maskDigit);
                        }

                        if (valDigit === maskDigit) {
                            maskDigitPosArr.push(v);
                            v += offset;
                        } else {
                            lastUntranslatedMaskChar = maskDigit;
                            maskDigitPosArr.push(v + maskDigitCount);
                            maskDigitCount++;
                        }

                        m += offset;
                    }
                }

                var lastMaskCharDigit = mask.charAt(lastMaskChar);
                if (maskLen === valLen + 1 && !jMask.translation[lastMaskCharDigit]) {
                    buf.push(lastMaskCharDigit);
                }

                var newVal = buf.join('');
                p.mapMaskdigitPositions(newVal, maskDigitPosArr, valLen);
                return newVal;
            },
            mapMaskdigitPositions: function(newVal, maskDigitPosArr, valLen) {
              var maskDiff = options.reverse ? newVal.length - valLen : 0;
              p.maskDigitPosMap = {};
              for (var i = 0; i < maskDigitPosArr.length; i++) {
                p.maskDigitPosMap[maskDigitPosArr[i] + maskDiff] = 1;
              }
            },
            callbacks: function (e) {
                var val = p.val(),
                    changed = val !== oldValue,
                    defaultArgs = [val, e, el, options],
                    callback = function(name, criteria, args) {
                        if (typeof options[name] === 'function' && criteria) {
                            options[name].apply(this, args);
                        }
                    };

                callback('onChange', changed === true, defaultArgs);
                callback('onKeyPress', changed === true, defaultArgs);
                callback('onComplete', val.length === mask.length, defaultArgs);
                callback('onInvalid', p.invalid.length > 0, [val, e, el, p.invalid, options]);
            }
        };

        el = $(el);
        var jMask = this, oldValue = p.val(), regexMask;

        mask = typeof mask === 'function' ? mask(p.val(), undefined, el,  options) : mask;

        // public methods
        jMask.mask = mask;
        jMask.options = options;
        jMask.remove = function() {
            var caret = p.getCaret();
            if (jMask.options.placeholder) {
                el.removeAttr('placeholder');
            }
            if (el.data('mask-maxlength')) {
                el.removeAttr('maxlength');
            }
            p.destroyEvents();
            p.val(jMask.getCleanVal());
            p.setCaret(caret);
            return el;
        };

        // get value without mask
        jMask.getCleanVal = function() {
           return p.getMasked(true);
        };

        // get masked value without the value being in the input or element
        jMask.getMaskedVal = function(val) {
           return p.getMasked(false, val);
        };

       jMask.init = function(onlyMask) {
            onlyMask = onlyMask || false;
            options = options || {};

            jMask.clearIfNotMatch  = $.jMaskGlobals.clearIfNotMatch;
            jMask.byPassKeys       = $.jMaskGlobals.byPassKeys;
            jMask.translation      = $.extend({}, $.jMaskGlobals.translation, options.translation);

            jMask = $.extend(true, {}, jMask, options);

            regexMask = p.getRegexMask();

            if (onlyMask) {
                p.events();
                p.val(p.getMasked());
            } else {
                if (options.placeholder) {
                    el.attr('placeholder' , options.placeholder);
                }

                // this is necessary, otherwise if the user submit the form
                // and then press the "back" button, the autocomplete will erase
                // the data. Works fine on IE9+, FF, Opera, Safari.
                if (el.data('mask')) {
                  el.attr('autocomplete', 'off');
                }

                // detect if is necessary let the user type freely.
                // for is a lot faster than forEach.
                for (var i = 0, maxlength = true; i < mask.length; i++) {
                    var translation = jMask.translation[mask.charAt(i)];
                    if (translation && translation.recursive) {
                        maxlength = false;
                        break;
                    }
                }

                if (maxlength) {
                    el.attr('maxlength', mask.length).data('mask-maxlength', true);
                }

                p.destroyEvents();
                p.events();

                var caret = p.getCaret();
                p.val(p.getMasked());
                p.setCaret(caret);
            }
        };

        jMask.init(!el.is('input'));
    };

    $.maskWatchers = {};
    var HTMLAttributes = function () {
        var input = $(this),
            options = {},
            prefix = 'data-mask-',
            mask = input.attr('data-mask');

        if (input.attr(prefix + 'reverse')) {
            options.reverse = true;
        }

        if (input.attr(prefix + 'clearifnotmatch')) {
            options.clearIfNotMatch = true;
        }

        if (input.attr(prefix + 'selectonfocus') === 'true') {
           options.selectOnFocus = true;
        }

        if (notSameMaskObject(input, mask, options)) {
            return input.data('mask', new Mask(this, mask, options));
        }
    },
    notSameMaskObject = function(field, mask, options) {
        options = options || {};
        var maskObject = $(field).data('mask'),
            stringify = JSON.stringify,
            value = $(field).val() || $(field).text();
        try {
            if (typeof mask === 'function') {
                mask = mask(value);
            }
            return typeof maskObject !== 'object' || stringify(maskObject.options) !== stringify(options) || maskObject.mask !== mask;
        } catch (e) {}
    },
    eventSupported = function(eventName) {
        var el = document.createElement('div'), isSupported;

        eventName = 'on' + eventName;
        isSupported = (eventName in el);

        if ( !isSupported ) {
            el.setAttribute(eventName, 'return;');
            isSupported = typeof el[eventName] === 'function';
        }
        el = null;

        return isSupported;
    };

    $.fn.mask = function(mask, options) {
        options = options || {};
        var selector = this.selector,
            globals = $.jMaskGlobals,
            interval = globals.watchInterval,
            watchInputs = options.watchInputs || globals.watchInputs,
            maskFunction = function() {
                if (notSameMaskObject(this, mask, options)) {
                    return $(this).data('mask', new Mask(this, mask, options));
                }
            };

        $(this).each(maskFunction);

        if (selector && selector !== '' && watchInputs) {
            clearInterval($.maskWatchers[selector]);
            $.maskWatchers[selector] = setInterval(function(){
                $(document).find(selector).each(maskFunction);
            }, interval);
        }
        return this;
    };

    $.fn.masked = function(val) {
        return this.data('mask').getMaskedVal(val);
    };

    $.fn.unmask = function() {
        clearInterval($.maskWatchers[this.selector]);
        delete $.maskWatchers[this.selector];
        return this.each(function() {
            var dataMask = $(this).data('mask');
            if (dataMask) {
                dataMask.remove().removeData('mask');
            }
        });
    };

    $.fn.cleanVal = function() {
        return this.data('mask').getCleanVal();
    };

    $.applyDataMask = function(selector) {
        selector = selector || $.jMaskGlobals.maskElements;
        var $selector = (selector instanceof $) ? selector : $(selector);
        $selector.filter($.jMaskGlobals.dataMaskAttr).each(HTMLAttributes);
    };

    var globals = {
        maskElements: 'input,td,span,div',
        dataMaskAttr: '*[data-mask]',
        dataMask: true,
        watchInterval: 300,
        watchInputs: true,
        keyStrokeCompensation: 10,
        // old versions of chrome dont work great with input event
        useInput: !/Chrome\/[2-4][0-9]|SamsungBrowser/.test(window.navigator.userAgent) && eventSupported('input'),
        watchDataMask: false,
        byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],
        translation: {
            '0': {pattern: /\d/},
            '9': {pattern: /\d/, optional: true},
            '#': {pattern: /\d/, recursive: true},
            'A': {pattern: /[a-zA-Z0-9]/},
            'S': {pattern: /[a-zA-Z]/}
        }
    };

    $.jMaskGlobals = $.jMaskGlobals || {};
    globals = $.jMaskGlobals = $.extend(true, {}, globals, $.jMaskGlobals);

    // looking for inputs with data-mask attribute
    if (globals.dataMask) {
        $.applyDataMask();
    }

    setInterval(function() {
        if ($.jMaskGlobals.watchDataMask) {
            $.applyDataMask();
        }
    }, globals.watchInterval);
}, window.jQuery, window.Zepto));




$(function () {
	$.jMaskGlobals = {
		maskElements: false,
		dataMaskAttr: false,
		dataMask: false,
		watchInterval: 300,
		watchInputs: false,
		watchDataMask: false,
		byPassKeys: [9, 16, 17, 18, 36, 37, 38, 39, 40, 91],
		translation: {
			'0': { pattern: /\d/, optional: true },
			'1': { pattern: /[0-1]/ },
			'2': { pattern: /[0-2]/ },
			'3': { pattern: /[0-3]/ },
			'4': { pattern: /[0-4]/ },
			'5': { pattern: /[0-5]/ },
			'6': { pattern: /[0-6]/ },
			'7': { pattern: /[0-7]/ },
			'8': { pattern: /[0-8]/ },
			'9': { pattern: /\d/ },
			'C': { pattern: /[a-zA-Z0-9áàâãéèêíïóôõöúçñÁÀÂÃÉÈÍÏÓÔÕÖÚÇÑ\ \'\.\,\-\+\&\/]/, recursive: true },
			'D': { pattern: /\d/, recursive: true },
			'N': { pattern: /[a-zA-Z0-9]/ },
			'X': { pattern: /[a-zA-Z0-9]/, recursive: true },
			'A': { pattern: /[a-zA-Z]/ },
			'M': { pattern: /[a-zA-ZáàâãéèêíïóôõöúçñÁÀÂÃÉÈÍÏÓÔÕÖÚÇÑ\ \'\.\-]/, recursive: true },
			'Z': { pattern: /[a-zA-Z]/, recursive: true },
			'E': { pattern: /[a-zA-Z0-9\.\@\-\_]/, recursive: true },
			'L': { pattern: /[a-z0-9\-\_]/, recursive: true },
			'U': { pattern: /[a-zA-Z0-9\:\/\.\#\&\?\@\-\_\,\;\=\+\%\'\"]/, recursive: true },
			'#': { pattern: /\-|\+|\d/, optional: true },
		}
	};
	$.jMaskRules = {
		'date': { mask: '39/19/2999', options: {selectOnFocus: true} },
		'datetime': { mask: '39/19/2999 29:59:59', options: {selectOnFocus: true} },
		'datetime-short': { mask: '39/19/2999 29:59', options: {selectOnFocus: true} },
		'time': { mask: '29:59:59', options: {selectOnFocus: true} },
		'time-short': { mask: '29:59', options: {selectOnFocus: true} },
		'uf': { mask: 'AA' },
		'cep': { mask: '99999-999', options: {selectOnFocus: true} },
		'cnh': { mask: '99999999999' },
		'cpf': { mask: '999.999.999-99' },
		'rg': { mask: '99.999.999-N' },
		'cnpj': { mask: '99.999.999/9999-99' },
		'phone': { mask: '9999-9999', options: {selectOnFocus: true} },
		'ddd-phone': { mask: '(99) 9999-9999', options: {selectOnFocus: true} },
		'alphanumeric': { mask: 'X' },
		'alpha': { mask: 'Z' },
		'name': { mask: 'M' },
		'company': { mask: 'C' },
		'email': { mask: 'E' },
		'url': { mask: 'U' },
		'number': { mask: 'D' },
		'integer': { mask: 'D' },
		'literal': { mask: 'L' },
		'float': { mask: '999.999.999.999.999,99', options: { reverse: true } },
		//'decimal' : 		{ mask:'999.999.999.999.999,99', options: { reverse: true } },
		'creditcard': { mask: '9999 9999 9999 9999' },
		'decimal': {
			mask: '###.###.###.###.###,##', options: {
				reverse: true,
				translation: {
					'#': {
						pattern: /-|\d/,
						recursive: true
					}
				},
				onChange: function (value, e) {
					e.target.value = value.replace(/(?!^)-/g, '').replace(/^,/, '').replace(/^-,/, '-').replace(/^-\./, '-');
					/*
					var target = e.target,
					position = target.selectionStart; // Capture initial position
					target.value = value.replace(/(?!^)-/g, '').replace(/^,/, '').replace(/^-,/, '-');
					target.selectionEnd = position; // Set the cursor back to the initial position.
					*/
				}
			}
		},
		'cell': {
			mask: function (val) {
				return val.replace(/\D/g, '').length === 9 ? '99999-9999' : '9999-99990';
			},
			options: {
				onKeyPress: function (val, e, field, options) {
					field.mask($.jMaskRules['cell'].mask.apply({}, arguments), options);
				}
			}
		},
		'ddd-cell': {
			mask: function (val) {
				return val.replace(/\D/g, '').length === 11 ? '(99) 99999-9999' : '(99) 9999-99990';
			},
			options: {
				onKeyPress: function (val, e, field, options) {
					field.mask($.jMaskRules['ddd-cell'].mask.apply({}, arguments), options);
				}
			}
		},
		'cpfcnpj': {
			mask: function (val) {
				return val.replace(/\D/g, '').length >= 12 ? '99.999.999/9999-99' : '999.999.999-990';
			},
			options: {
				onKeyPress: function (val, e, field, options) {
					field.mask($.jMaskRules['cpfcnpj'].mask.apply({}, arguments), options);
				}
			}
		},
		'boleto': {
			mask: function (val) {
				return boletos.mask(val);
			},
			options: {
				onKeyPress: function (val, e, field, options) {
					var masked = field.data('maskedmask'), newmask = $.jMaskRules['boleto'].mask.apply({}, arguments);
					if (newmask !== masked) field.data('maskedmask', newmask).mask(newmask, options);
				}
			}
		}
	}
	$.jMaskPatterns = {
		'url': new RegExp("^([a-zA-Z]{3,10}\:\/\/|\/\/)?[a-z0-9]+([\-\.]{1}[a-zA-Z0-9]+)*\.[a-z]{2,5}(:[0-9]{1,5})?(\/.*)?$"),
		'email': new RegExp("[a-zA-Z0-9\-\+\.\_]+\@[a-zA-Z0-9\-\+\.\_]+\.[a-zA-Z0-9]{2,3}$"),
		'phone': new RegExp("^[2-9][0-9]{3}-[0-9]{4}$"),
		'ddd-phone': new RegExp("^[\(][0-9]{2}[\)][\ ][2-9][0-9]{3}-[0-9]{4}$"),
		'cell': new RegExp("^[2-9][0-9]{3,4}-[0-9]{4}$"),
		'ddd-cell': new RegExp("^[\(][0-9]{2}[\)][\ ][2-9][0-9]{3,4}-[0-9]{4}$"),
		'cnh': new RegExp("^([0-9]{11})$"),
		'cpf': new RegExp("^([0-9]{3}[\.]?[0-9]{3}[\.]?[0-9]{3}[\-]?[0-9]{2})$"),
		'cnpj': new RegExp("^([0-9]{2,3}[\.]?[0-9]{3}[\.]?[0-9]{3}[\/]?[0-9]{4}[\-]?[0-9]{2})$"),
		'cep': new RegExp("^[0-9]{5}[\-]?[0-9]{3}$"),
		'uf': new RegExp("^(AC|AL|AM|AP|BA|CE|DF|ES|GO|MA|MG|MS|MT|PA|PB|PE|PI|PR|RJ|RN|RO|RR|RS|SC|SE|SP|TO)$", 'i'),
		'date': new RegExp("^((0?[1-9]|[12][0-9]|3[01])[\/](0?[1-9]|1[012])[\/]([0-9]{4}))|(([0-9]{4})[\-](0?[1-9]|1[012])[\-](0?[1-9]|[12][0-9]|3[01]))$"),
		'datetime': new RegExp("^((0?[1-9]|[12][0-9]|3[01])[\/](0?[1-9]|1[012])[\/]([0-9]{4}))|(([0-9]{4})[\-](0?[1-9]|1[012])[\-](0?[1-9]|[12][0-9]|3[01]))[\ ](0[0-9]|1[0-9]|2[0-3]):([0-5][0-9]):([0-5][0-9])$"),
		'datetime-short': new RegExp("^((0?[1-9]|[12][0-9]|3[01])[\/](0?[1-9]|1[012])[\/]([0-9]{4}))|(([0-9]{4})[\-](0?[1-9]|1[012])[\-](0?[1-9]|[12][0-9]|3[01]))[\ ](0[0-9]|1[0-9]|2[0-3]):([0-5][0-9])$"),
		'time': new RegExp("^(00|0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[0-5][0-9]):(0[0-9]|[0-5][0-9])$"),
		'time-short': new RegExp("^(00|0[0-9]|1[0-9]|2[0-3]):(0[0-9]|[0-5][0-9])$"),
		'dddphone': this['ddd-phone'],
		'dddcell': this['ddd-cell'],
		'datetimeshort': this['datetime-short'],
		'timeshort': this['time-short'],
	}
	$.jMaskPatternsErrors = {
		'url': 'Endereço inválido',
		'email': 'E-Mail inválido',
		'phone': 'Número inválido',
		'ddd-phone': 'Número inválido',
		'cell': 'Número inválido',
		'ddd-cell': 'Número inválido',
		'cpf': 'CPF inválido',
		'cnpj': 'CNPJ inválido',
		'cpfcnpj': 'Número inválido',
		'cep': 'CEP inválido',
		'uf': 'UF inválido',
		'date': 'Data inválida',
		'datetime': 'Data/Hora inválida',
		'datetime-short': 'Data/Hora inválida',
		'time': 'Hora inválida',
		'time-short': 'Hora inválida',
	}

	$.jMaskValidates = {
		cnh: function(cnh){
			cnh = cnh.replace(/[^\d]/g, '')+'';
			if (cnh == "00000000000" ||
				cnh == "11111111111" ||
				cnh == "22222222222" ||
				cnh == "33333333333" ||
				cnh == "44444444444" ||
				cnh == "55555555555" ||
				cnh == "66666666666" ||
				cnh == "77777777777" ||
				cnh == "88888888888" ||
				cnh == "99999999999") return true;
			var char1 = cnh.charAt(0);
			if (cnh.length !== 11 || char1.repeat(11) === cnh) {
				return false;
			}
			for (var i = 0, j = 9, v = 0; i < 9; ++i, --j) {
				v += +(cnh.charAt(i) * j);
			}
			var dsc = 0,
				vl1 = v % 11;
			if (vl1 >= 10) {
				vl1 = 0;
				dsc = 2;
			}
			for (i = 0, j = 1, v = 0; i < 9; ++i, ++j) {
				v += +(cnh.charAt(i) * j);
			}
			var x = v % 11;
			var vl2 = (x >= 10) ? 0 : x - dsc;
			return ('' + vl1 + vl2) === cnh.substr(-2);
		},
		cpfcnpj: function (v) {
			v = v.replace(/[^\d]+/g, '');
			if (v.length > 11) return $.jMaskValidates.cnpj(v);
			else return $.jMaskValidates.cpf(v);
		},
		cpf: function (v) {
			var Soma;
			var Resto;
			Soma = 0;
			v = v.replace(/[^\d]+/g, '')+'';
			if (v == "00000000000" ||
				v == "11111111111" ||
				v == "22222222222" ||
				v == "33333333333" ||
				v == "44444444444" ||
				v == "55555555555" ||
				v == "66666666666" ||
				v == "77777777777" ||
				v == "88888888888" ||
				v == "99999999999") return true;
			for (i = 1; i <= 9; i++)
				Soma = Soma + parseInt(v.substring(i - 1, i)) * (11 - i);
			Resto = (Soma * 10) % 11;
			if ((Resto == 10) || (Resto == 11))
				Resto = 0;
			if (Resto != parseInt(v.substring(9, 10))) return false;
			Soma = 0;
			for (i = 1; i <= 10; i++) Soma = Soma + parseInt(v.substring(i - 1, i)) * (12 - i);
			Resto = (Soma * 10) % 11;
			if ((Resto == 10) || (Resto == 11))
				Resto = 0;
			if (Resto != parseInt(v.substring(10, 11))) return false;
			return true;
		},
		cnpj: function (v) {
			cnpj = v.replace(/[^\d]+/g, '');
			if (cnpj == '') return false;
			if (cnpj.length != 14)
				return false;
			if (cnpj == "00000000000000" ||
				cnpj == "11111111111111" ||
				cnpj == "22222222222222" ||
				cnpj == "33333333333333" ||
				cnpj == "44444444444444" ||
				cnpj == "55555555555555" ||
				cnpj == "66666666666666" ||
				cnpj == "77777777777777" ||
				cnpj == "88888888888888" ||
				cnpj == "99999999999999") return true;
			tamanho = cnpj.length - 2
			numeros = cnpj.substring(0, tamanho);
			digitos = cnpj.substring(tamanho);
			soma = 0;
			pos = tamanho - 7;
			for (i = tamanho; i >= 1; i--) {
				soma += numeros.charAt(tamanho - i) * pos--;
				if (pos < 2)
					pos = 9;
			}
			resultado = soma % 11 < 2 ? 0 : 11 - soma % 11;
			if (resultado != digitos.charAt(0)) return false;
			tamanho = tamanho + 1;
			numeros = cnpj.substring(0, tamanho);
			soma = 0;
			pos = tamanho - 7;
			for (i = tamanho; i >= 1; i--) {
				soma += numeros.charAt(tamanho - i) * pos--;
				if (pos < 2)
					pos = 9;
			}
			resultado = soma % 11 < 2 ? 0 : 11 - soma % 11;
			if (resultado != digitos.charAt(1)) return false;
			return true;
		},
		boleto: function (v) {
			if (v === '' || v.length === 0) return true;
			var data = boletos.test(v);
			if (data.fullvalid) return true;
			else if (data.validtype == 'boleto' && !data.boleto.errorblock.length) return true;
			else if (data.validtype == 'fatura' && !data.fatura.errorblock.length) return true;
			else if (!data.boleto.validblock.length && !data.fatura.validblock.length && v.length < 12) return true;
			return false;
		},
		creditcard: function(v){
			var cardnumber = v.replace(/[^0-9]+/g, '');

			/*
			self::AMERICAN_EXPRESS => '/^3[47]\d{13}$/',
			self::DINERS_CLUB => '/^3(?:0[0-5]|[68]\d)\d{11}$/',
			self::ELO => '/(4011|431274|438935|451416|457393|4576|457631|457632|504175|627780|636297|636368|636369|(6503[1-3])|(6500(3[5-9]|4[0-9]|5[0-1]))|(6504(0[5-9]|1[0-9]|2[0-9]|3[0-9]))|(650(48[5-9]|49[0-9]|50[0-9]|51[1-9]|52[0-9]|53[0-7]))|(6505(4[0-9]|5[0-9]|6[0-9]|7[0-9]|8[0-9]|9[0-8]))|(6507(0[0-9]|1[0-8]))|(6507(2[0-7]))|(650(90[1-9]|91[0-9]|920))|(6516(5[2-9]|6[0-9]|7[0-9]))|(6550(0[0-9]|1[1-9]))|(6550(2[1-9]|3[0-9]|4[0-9]|5[0-8]))|(506(699|77[0-8]|7[1-6][0-9))|(509([0-9][0-9][0-9])))/',
			self::HIPERCARD => '/^(606282\d{10}(\d{3})?)|(3841\d{15})$/',
			self::MASTERCARD => '/^5[1-5]\d{14}$|^2(?:2(?:2[1-9]|[3-9]\d)|[3-6]\d\d|7(?:[01]\d|20))\d{12}$/',
			self::VISA => '/^4\d{12}(?:\d{3})?$/',
			*/

			var cards = {
				Visa	  : /^4[0-9]{12}(?:[0-9]{3})/,
				Master	: /^5[1-5]\d{14}$|^2(?:2(?:2[1-9]|[3-9]\d)|[3-6]\d\d|7(?:[01]\d|20))\d{12}$/,
				Diners	: /^3(?:0[0-5]|[68][0-9])[0-9]{11}/,
				Amex	  : /^3[47][0-9]{13}/,
				Discover  : /^6(?:011|5[0-9]{2})[0-9]{12}/,
				Hipercard : /^(606282\d{10}(\d{3})?)|(3841\d{15})/,
				Elo	   : /^(4011|431274|438935|451416|457393|4576|457631|457632|504175|627780|636297|636368|636369|(6503[1-3])|(6500(3[5-9]|4[0-9]|5[0-1]))|(6504(0[5-9]|1[0-9]|2[0-9]|3[0-9]))|(650(48[5-9]|49[0-9]|50[0-9]|51[1-9]|52[0-9]|53[0-7]))|(6505(4[0-9]|5[0-9]|6[0-9]|7[0-9]|8[0-9]|9[0-8]))|(6507(0[0-9]|1[0-8]))|(6507(2[0-7]))|(650(90[1-9]|91[0-9]|920))|(6516(5[2-9]|6[0-9]|7[0-9]))|(6550(0[0-9]|1[1-9]))|(6550(2[1-9]|3[0-9]|4[0-9]|5[0-8]))|(506(699|77[0-8]|7[1-6][0-9))|(509([0-9][0-9][0-9])))/,
				JCB	   : /^(?:2131|1800|35\d{3})\d{11}/,
				Aura	  : /^(5078\d{2})(\d{2})(\d{11})$/
			};

			for (var flag in cards) {
				if(cards[flag].test(cardnumber)) {
					return flag;
				}
			}
			return false;
		}
	};
	$.jMaskPaste = {
		_numeric: function (v) {
			return (v + '').replace(/\D+/g, "");
		},
		_alpha: function (v) {
			return (v + '').replace(/[^a-zA-Z]+/g, "");
		},
		_alphanumeric: function (v) {
			return (v + '').replace(/\W+/g, "");
		}
	};
	$.jMaskPaste['phone'] = $.jMaskPaste._numeric;
	$.jMaskPaste['ddd-phone'] = $.jMaskPaste._numeric;
	$.jMaskPaste['cell'] = $.jMaskPaste._numeric;
	$.jMaskPaste['ddd-cell'] = $.jMaskPaste._numeric;
	$.jMaskPaste['cep'] = $.jMaskPaste._numeric;
	$.jMaskPaste['date'] = $.jMaskPaste._numeric;
	$.jMaskPaste['datetime'] = $.jMaskPaste._numeric;
	$.jMaskPaste['datetime-short'] = $.jMaskPaste._numeric;
	$.jMaskPaste['time'] = $.jMaskPaste._numeric;
	$.jMaskPaste['time-short'] = $.jMaskPaste._numeric;
	$.jMaskPaste['cpfcnpj'] = $.jMaskPaste._numeric;
	$.jMaskPaste['cnh'] = $.jMaskPaste._numeric;
	$.jMaskPaste['cpf'] = $.jMaskPaste._numeric;
	$.jMaskPaste['cnpj'] = $.jMaskPaste._numeric;
	$.jMaskPaste['boleto'] = $.jMaskPaste._numeric;

	$.fn.mascara = function (mask, options) {
		var $elems = $(this);
		var $fd = [];
		$elems.each(function () {
			var $field = $(this);
			if (mask === false) {
				$field.unmask();
			} else {
				var m = mask || $field.data('mask');
				if (m) {
					$field.data('validate', m);
					var rules = $.jMaskRules[m];
					if (!rules) {
						rules = {
							mask: m,
							options: options || {}
						}
					}
					if (rules.mask) {
						rules.mask = (typeof rules.mask == 'number') ? ''+rules.mask : rules.mask;
						$field.mask(rules.mask, rules.options);
						if ($.jMaskPaste[m]) {
							$field.on('paste', function (event) {
								var text = event.originalEvent.clipboardData.getData('text');
								text = $.jMaskPaste[m](text);
								$field.val(text);
								var len = text.length * 2;
								setTimeout(function () {
									$field.get(0).setSelectionRange(len, len);
								}, 100);
								event.preventDefault();
							});
						}
					}
				}
			}
		});
	}
	$.fn.valida = function (p, trig) {
		var $field = $(this);
		var value = $.trim($field.val());
		var v = p || $field.data('validate');
		if (v) {
			var pattern = $.jMaskPatterns[v];
			if (value && pattern) {
				if (!pattern.test(value)) {
					$field.trigger('invalid', [v]);
					return false;
				}
			}
			var validate = $.jMaskValidates[v];
			var rv;
			if (value && validate) {
				rv = validate(value);
				if (!rv) {
					$field.trigger('invalid', [v,rv,$.jMaskPatternsErrors[v]]);
					return false;
				}
			}
			$field.trigger('valid', [v,rv]);
		}
		return true;
	}
	$.valida = function (value,v){
		var pattern = $.jMaskPatterns[v];
		if (value && pattern) {
			if (!pattern.test(value)) {
				return false;
			}
		}
		var validate = $.jMaskValidates[v];
		if (value && validate) {
			if (!validate(value)) {
				return false;
			}
		}
		return true;
	}

	/*
	var vstx = {
		'url' 			: 'sourcecomasdasasasdcom'
		'email' 		: 'marino12++@asd-asd.com.br'
	}


	console.log('url'			,vstx['url']			,$.jMaskPatterns['url'].test(vstx['url']),			$.jMaskPatterns['url'].exec(vstx['url']));
	console.log('email'			,vstx['email']			,$.jMaskPatterns['email'].test(vstx['email']),		$.jMaskPatterns['email'].exec(vstx['email']));
	console.log('email'			,$.jMaskPatterns['email'].test('marino@asd.com'));
	console.log('phone'			,$.jMaskPatterns['phone'].test('2129-7254'));
	console.log('cell'			,$.jMaskPatterns['cell'].test('96587-7254'));
	console.log('ddd-cell'		,$.jMaskPatterns['ddd-cell'].test('(11) 96587-7254'));
	console.log('cpf'			,$.jMaskPatterns['cpf'].test('205.198.808-03'));
	console.log('cnpj'			,$.jMaskPatterns['cnpj'].test('26.215.236/0001-03'));
	console.log('cep'			,$.jMaskPatterns['cep'].test('06753-145'));
	console.log('uf'			,$.jMaskPatterns['uf'].test('SP'));
	console.log('date'			,$.jMaskPatterns['date'].test('30/01/1945'));
	console.log('datetime'		,$.jMaskPatterns['datetime'].test('29/10/1945 24:59:52'));
	console.log('datetime-short',$.jMaskPatterns['datetime-short'].test('29/10/1945 22:45'));
	console.log('time', $.jMaskPatterns['time'].test('14:52:45'));
	console.log('time-short', $.jMaskPatterns['time-short'].test('14:52'));
	*/
});
